{ config, pkgs, lib, ... }:

let
  displayId = "99";
  sunshine-xorg-dir = "/var/lib/sunshine-xorg/";
  xauthority = "${sunshine-xorg-dir}/Xauthority";

  # NOTE: Generate an `Xauthority` for the `Xorg` server
  sunshineXorgPre = pkgs.writeShellScript "sunshine-xorg-prestart" ''
    set -euo pipefail

    rm -f ${xauthority}
    : > ${xauthority}

    cookie="$(${lib.getExe' pkgs.util-linux "mcookie"})"
    xauth=${lib.getExe' pkgs.xorg.xauth "xauth"}
    hn="$(${lib.getExe pkgs.hostname})"

    $xauth -f ${xauthority} add ":${displayId}" . "$cookie"
    $xauth -f ${xauthority} add "unix:${displayId}" . "$cookie"
    $xauth -f ${xauthority} add "$hn/unix:${displayId}" . "$cookie"

    chown root:users ${xauthority}
    chmod 0640 ${xauthority}
  '';

  modulePath = lib.pipe [
    "xorgserver"
    "xf86inputlibinput"
    "xf86inputevdev"
  ] [
    (lib.map (lib.flip lib.pipe [
      (lib.flip lib.getAttr pkgs.xorg)
      (p: "${p}/lib/xorg/modules")
    ]))
    (lib.concatStringsSep ",")
  ];

  # TODO: Create predicible name for the VKMS Card
  vkmsCard = if false then "vkms" else "card2";

  # NOTE: Generate a configuration for the `Xorg` server
  #       (consits of screen and input settings)
  xorgConfDir = pkgs.runCommand "sunshine-xorg-confdir" {} ''
    mkdir -p $out

    ${lib.getExe' pkgs.libxcvt "cvt"} 3120 1440 60

    # Headless screen setup
    cat > $out/10-screen.conf <<XF86CONF
    Section "Device"
      Identifier  "vkms"
      Driver      "modesetting"
      Option      "kmsdev" "/dev/dri/${vkmsCard}"
    EndSection

    Section "Monitor"
      Identifier "Monitor0"

      $(${lib.getExe' pkgs.libxcvt "cvt"} 3120 1440 60)
    EndSection

    Section "Screen"
      Identifier "Screen0"
      Device "vkms"
      Monitor "Monitor0"
      DefaultDepth 24

      SubSection "Display"
        Depth 24

        # NOTE: 1080p is default (first entry)
        Modes "1920x1080" "3120x1440_60.00"

        # Set maximum framebuffer size (needed when starting in a smaller one)
        Virtual 3120 1440
      EndSubSection
    EndSection

    Section "ServerLayout"
      Identifier "Layout0"
      Screen "Screen0"
    EndSection

    Section "ServerFlags"
      Option "AutoAddDevices" "true"
      Option "AutoEnableDevices" "true"
    EndSection
    XF86CONF

    # `libinput` catchall (device-path based)
    cat > $out/40-libinput.conf <<'XF86CONF'
    Section "InputClass"
      Identifier "libinput catchall"
      MatchDevicePath "/dev/input/event*"
      Driver "libinput"
    EndSection
    XF86CONF
  '';
in
{
  # NOTE: Base `sunshine` service configuration

  services.sunshine = {
    enable = true;
    autoStart = true;
    openFirewall = true;
    # NOTE: Needed if caputring real screen
    capSysAdmin = false;
    settings = {
      # HACK: Default is `47989`, which `+21` (done by the `sunshine` module) overlaps with `OpenCloud`'s `48010`
      port = 47689;
      # NOTE: Using headless `Xorg` server
      capture = "x11";
    };
    applications = {
      env = {
        PATH = "$(PATH):$(HOME)/.local/bin";
        # NOTE: These technically get inherited from the `sunshine` service,
        #       but it does not hurt to have them here as well
        DISPLAY = ":${displayId}";
        XAUTHORITY = "${xauthority}";
      };
      apps = [
        {
          name = "Steam Big Picture";
          image-path = "steam.png";
          detached = [
            # TODO: Better WM/DE, look into the autogenerated `gamescopeSession`
            "${lib.getExe' pkgs.openbox "openbox"}"
            # HACK: Pray to the `steam-run` gods
            "${lib.getExe config.programs.steam.package.run-free} ${lib.getExe config.programs.steam.package}"
          ];
        }
        {
          name = "Desktop";
          image-path = "desktop.png";
        }
        {
          name = "Cheetah Desktop";
          image-path = let
            # TODO: Extract function from the `topology` config and expose through `lib`
            removebg = { image, fuzz ? 10, ... }:
              pkgs.runCommand "${image.name}.png" {
                buildInputs = [
                  pkgs.imagemagick
                ];
              } ''
                magick ${image} \
                  -monitor \
                  -bordercolor white \
                  -border 1x1 \
                  -alpha set \
                  -channel RGBA \
                  -fuzz ${builtins.toString fuzz}% \
                  -fill none \
                  -floodfill +0+0 white \
                  -shave 1x1 \
                  $out
              '';
          in removebg {
            image = pkgs.fetchurl {
              name = "cheetah.jpg";
              url = "https://m.media-amazon.com/images/I/51OFxuD1GgL._AC_SL1000_.jpg";
              hash = "sha256-Lvylh1geh81FZpqK1shj108M217zobWRgR4mEfbvKrc=";
            };
            fuzz = 20;
          };
          prep-cmd = [
            {
              do = "${lib.getExe pkgs.xrandr} --output Virtual-1 --mode 3120x1440_60.00";
              undo = "${lib.getExe pkgs.xrandr} --output Virtual-1 --mode 1920x1080";
            }
          ];
        }
      ];
    };
  };

  # NOTE: Virtual Input Devices configuration

  boot.kernelModules = [
    "uhid"
    "uinput"
  ];

  hardware.uinput.enable = true;

  services.udev.extraRules = lib.concatStringsSep "\n" [
    # NOTE: As noted in <https://myme.no/posts/2025-12-11-hifi-sunshine-on-nixos.html>
    ''KERNEL=="uhid",   MODE="0660", GROUP="input"''
    ''KERNEL=="uinput", MODE="0660", GROUP="input", SYMLINK+="uinput"''
    # FIXME: Does not get created
    # ''SUBSYSTEM=="drm", KERNEL=="card*", DRIVER=="vkms", SYMLINK+="dri/vkms"''
  ];

  users.users.jeeves.extraGroups = [
    "input"
    "uinput"
    "video"
    "render"
  ];

  # NOTE: Custom Xorg Server configuration

  # For `sunshineXorgPre`
  systemd.tmpfiles.rules = [
    "d ${sunshine-xorg-dir} 2775 root users - -"
  ];

  systemd.services.sunshine-xorg = {
    description = "Headless Xorg (:${displayId}) for Sunshine (dummy + libinput)";
    after = [ "network.target" ];
    wantedBy = [ "multi-user.target" ];

    serviceConfig = {
      Type = "simple";
      Restart = "always";
      RestartSec = 2;

      ExecStartPre = sunshineXorgPre;

      ExecStart = ''
        ${lib.getExe' pkgs.xorg.xorgserver "Xorg"} :${displayId} \
          -modulepath ${modulePath} \
          -configdir ${xorgConfDir} \
          -auth ${xauthority} \
          -noreset -nolisten tcp \
          -logfile ${sunshine-xorg-dir}/Xorg.${displayId}.log
      '';
    };
  };

  # NOTE: Augemntation of the `sunshine` user service (generated by the module)

  systemd.user.services.sunshine = {
    after = [ "sunshine-xorg.service" ];
    wants = [ "sunshine-xorg.service" ];

    # TODO: (somehow) restart when configuration files change
    # reloadIfChanged = true;

    environment = {
      DISPLAY = ":${displayId}";
      XAUTHORITY = "${xauthority}";
    };
    serviceConfig = {
      PrivateDevices = false;
    };
  };

  # NOTE: Virtual host for the Web UI of `sunshine`

  services.nginx = {
    virtualHosts."sunshine.jeeves.reo101.xyz" = {
      forceSSL = true;
      useACMEHost = "jeeves.reo101.xyz";
      locations."/" = {
        proxyPass = "https://127.0.0.1:${builtins.toString (config.services.sunshine.settings.port + 1)}";
        proxyWebsockets = true;
        extraConfig = /* nginx */ ''
          proxy_set_header Host $host;
          proxy_set_header X-Real-IP $remote_addr;
          proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
          proxy_set_header X-Forwarded-Proto $scheme;
        '';
      };
    };
  };
}
