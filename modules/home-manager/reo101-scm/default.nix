{ lib, pkgs, config, ... }:

let
  cfg = config.reo101.scm;

  inherit (lib)
    mkEnableOption
    types
    mkIf
    optionals
    mkMerge;
in
{
  imports =
    [
    ];

  options =
    {
      reo101.scm = {
        git = {
          enable = mkEnableOption "reo101 git setup";
        };
        jj = {
          enable = mkEnableOption "reo101 jj setup";
          nvim = mkEnableOption "Integration with `hunk.nvim` and `jj-diffconflicts`" // {
            default = true;
          };
        };
      };
    };

  config = let
    # TODO: agenix???
    # TODO: module options???
    name = "reo101";
    email = "pavel.atanasov2001@gmail.com";
    # NOTE: GPG
    # key = "675AA7EF13964ACB";
    # NOTE: YubiKey
    key = "7DA978E6383E5885";
  in {
    home.packages = with pkgs;
      builtins.concatLists [
        (optionals cfg.git.enable [
          # git
          gh
        ])
        (optionals cfg.jj.enable [
          # jujutsu
          watchman
          # Generate jj fix config from .pre-commit-config.yaml
          (writeShellApplication {
            name = "jj-gen-fix-config";
            runtimeInputs = [ yq-go jq coreutils gnugrep ];
            text = ''
              REPO_ROOT="$(jj root)"
              CONFIG_FILE="''${1:-$REPO_ROOT/.pre-commit-config.yaml}"
              OUTPUT_FILE="$REPO_ROOT/.jj/repo/config.toml"

              if [[ ! -f "$CONFIG_FILE" ]]; then
                echo "Error: $CONFIG_FILE not found" >&2
                exit 1
              fi

              mkdir -p "$(dirname "$OUTPUT_FILE")"

              # Map pre-commit hook IDs to jj fix tool configs
              # Only include formatters that work with stdin→stdout
              generate_fix_config() {
                local id="$1"
                local entry="$2"
                local files="$3"

                # Extract base command (first word of entry)
                local cmd
                cmd=$(echo "$entry" | awk '{print $1}')

                case "$id" in
                  nixfmt|nixfmt-rfc-style)
                    echo "[fix.tools.nixfmt]"
                    echo "command = [\"$cmd\"]"
                    echo "patterns = [\"glob:'**/*.nix'\"]"
                    echo ""
                    ;;
                  prettier)
                    echo "[fix.tools.prettier]"
                    echo "command = [\"$cmd\", \"--stdin-filepath\", \"\$path\"]"
                    echo "patterns = [\"glob:'**/*.json'\", \"glob:'**/*.yaml'\", \"glob:'**/*.yml'\", \"glob:'**/*.md'\"]"
                    echo ""
                    ;;
                  rustfmt)
                    # Detect edition from Cargo.toml (package.edition or workspace.package.edition), default to 2024
                    local rust_edition="2024"
                    if [[ -f "$REPO_ROOT/Cargo.toml" ]]; then
                      rust_edition=$(yq -p toml -o yaml '.package.edition // .workspace.package.edition // "2024"' "$REPO_ROOT/Cargo.toml")
                    fi
                    echo "[fix.tools.rustfmt]"
                    echo "command = [\"rustfmt\", \"--edition=$rust_edition\", \"--emit=stdout\"]"
                    echo "patterns = [\"glob:'**/*.rs'\"]"
                    echo ""
                    ;;
                  *)
                    echo "# Skipping $id: not a known stdin→stdout formatter" >&2
                    ;;
                esac
              }

              {
                echo "# Generated by jj-gen-fix-config from $CONFIG_FILE"
                echo "# Regenerate with: jj-gen-fix-config"
                echo ""

                yq -o=json "$CONFIG_FILE" | jq -r '.repos[].hooks[] | "\(.id)\t\(.entry)\t\(.files)"' | \
                while IFS=$'\t' read -r id entry files; do
                  generate_fix_config "$id" "$entry" "$files"
                done
              } > "$OUTPUT_FILE"

              echo "Generated $OUTPUT_FILE"
              cat "$OUTPUT_FILE"
            '';
          })
        ])
      ];

    programs.git = mkIf cfg.git.enable {
      enable = true;
      package = pkgs.gitFull;
      signing = {
        signByDefault = true;
        inherit key;
      };
      lfs = {
        enable = true;
      };
      settings = {
        user = {
          inherit name email;
        };
        init.defaultBranch = "master";
      };
    };

    programs.jujutsu = mkIf cfg.jj.enable {
      enable = true;
      package = pkgs.jujutsu;
      settings = {
        user = {
          inherit name email;
        };
        git = {
          fetch = ["origin" "upstream"];
          push = "origin";
          private-commits = "description(glob:'wip:*')";
          sign-on-push = true;
        };
        remotes = {
          origin.auto-track-bookmarks = "glob:*";
        };
        signing = {
          backend = "gpg";
          behaviour = "drop";
          inherit key;
        };
        fsmonitor = {
          backend = "watchman";
          watchman = {
            register-snapshot-trigger = true;
          };
        };
        ui = mkMerge [
          {
            color = "always";
            show-cryptographic-signatures = true;
          }
          (mkIf cfg.jj.nvim {
            # pager = "nvim";
            editor = "nvim -b";
            diff-editor = [
              "nvim"
              "-c"
              "DiffEditor $left $right $output"
            ];
          })
        ];
        merge-tools = {
          diffconflicts = mkIf cfg.jj.nvim {
            program = "nvim";
            merge-args = [
              "-c" "let g:jj_diffconflicts_marker_length=$marker_length"
              "-c" "JJDiffConflicts!" "$output" "$base" "$left" "$right"
            ];
            # NOTE: for no history view
            # merge-args = [
            #   "-c" "JJDiffConflicts!" "$output"
            # ];
            merge-tool-edits-conflict-markers = true;
          };
        };
        revset-aliases = {
          "stragglers" = /* jj_revset */ ''
            (visible_heads() & mine()) ~ trunk()
          '';
          "bases" = /* jj_revset */ ''
            master | main
          '';
          "closest_bookmark(to)" = /* jj_revset */ ''
            heads(::to & bookmarks())
          '';
          "closest_pushable(to)" = /* jj_revset */ ''
            heads(::to & mutable() & ~description(exact:"") & (~empty() | merges()))
          '';
          "downstream(x,y)" = /* jj_revset */ ''
            (x::y) & y
          '';
          "branches" = /* jj_revset */ ''
            downstream(trunk(), bookmarks()) & mine()
          '';
          "branchesandheads" = /* jj_revset */ ''
            branches | (heads(trunk()::) & mine())
          '';
          "currbranch" = /* jj_revset */ ''
            latest(branches::@- & branches)
          '';
          "nextbranch" = /* jj_revset */ ''
            roots(@:: & branchesandheads)
          '';
        };
        aliases = {
          s = ["status"];
          e = ["edit"];
          d = ["diff"];
          l  = [ "log" ];
          ls = [ "log" "--summary" ];
          la = [ "log" "--revisions" "::" ];

          drag = ["bookmark" "move" "--from" "closest_bookmark(@-)" "--to" "@-"];
          sync = ["git" "fetch" "--all-remotes"];
          evolve = ["rebase" "--skip-emptied" "-d" "trunk()"];
          pullup = ["evolve" "-s" "all:stragglers"];
          touch = ["describe" "--reset-author" "--no-edit"];
          pre-commit = [
            "util" "exec" "--"
            "sh" "-c" /* sh */ "jj diff -r @ --name-only --no-pager | xargs pre-commit run --files"
          ];
          gen-fix-config = [
            "util" "exec" "--" "jj-gen-fix-config"
          ];

          pl = ["obslog" "-p"];
          # xl = ["log" "-r" "all()"];

          # cl = ["git" "push" "-c" "@-"];
          # push = ["git" "push" "--all"];

          configure = ["config" "edit" "--repo"];

          ".." = ["edit" "-r" "@-"];
          ",," = ["edit" "-r" "@+"];
        };
        template-aliases = {
          "format_timestamp(ts)" = /* jj_template */ ''
            if(
              ts.after("2 weeks ago"),
              ts.ago(),
              ts.format("%b %d, %Y %H:%M"),
            )
          '';

          # id.shortest(12).prefix() ++ "[" ++ id.shortest(12).rest() ++ "]"
          "format_short_id(id)" = /* jj_template */ ''
            id.shortest(12).prefix() ++ id.shortest(12).rest()
          '';
          "format_timestamp(timestamp)" = /* jj_template */ ''
            timestamp.ago()
          '';
          "format_short_signature(signature)" = /* jj_template */ ''
            signature.name()
          '';
          "format_detailed_signature(signature)" = /* jj_template */ ''
            signature.name() ++ " (" ++ signature.email() ++ ")"
          '';

          builtin_log_detailed = /* jj_template */ ''
            "\n\n\n" ++
            concat(
              "Change ID: " ++ format_short_id(change_id) ++ "\n",
              "Commit ID: " ++ format_short_id(commit_id) ++ "\n",
              surround("Bookmarks: ", "\n", separate(" ", local_bookmarks, remote_bookmarks)),
              surround("Tags     : ", "\n", tags),
              if(config("ui.show-cryptographic-signatures").as_boolean(),
                "Signature: " ++ format_detailed_cryptographic_signature(signature),
                "Signature: (not shown)"),
              "\n",
              "Author   : " ++ format_detailed_signature(author) ++ "\n",
              "Committer: " ++ format_detailed_signature(committer)  ++ "\n",
                indent("    ",
                coalesce(description, label(if(empty, "empty"), description_placeholder) ++ "\n")),
              "\n",
            )
          '';
        };
        templates = {
          log_node = /* jj_template */ ''
            coalesce(
              if(!self, label("elided", "▪")),
              if(current_working_copy, "●"),
              if(immutable, "⊗", "○"),
            )
          '';
          git_push_bookmark = /* jj_template */ ''
            "reo101/" ++ change_id.short()
          '';
          draft_commit_description = /* jj_template */ ''
            concat(
              builtin_draft_commit_description,
              "\nJJ: ignore-rest\n",
              diff.git(),
            )
          '';
        };
        revsets = {
          # log = "@ | bases | branches | curbranch::@ | @::nextbranch | downstream(@, branchesandheads)";
          log = "present(@) | present(trunk()) | ancestors(remote_bookmarks().. | @.., 8)";
        };
      };
    };
  };

  meta = {
    maintainers = with lib.maintainers; [ reo101 ];
  };
}
