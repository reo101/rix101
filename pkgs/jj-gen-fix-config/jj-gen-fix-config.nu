#!/usr/bin/env nu

use std

# Generate jj fix config from .pre-commit-config.yaml
# Maps pre-commit hook IDs to jj fix tool configs

def main [
    config_file?: string  # Path to pre-commit config (default: .pre-commit-config.yaml in jj root)
    --simple (-s)  # Generate a single pre-commit tool instead of individual formatter configs
] {
    let repo_root = (^jj root)
    let config_file = $config_file | default ($repo_root | path join ".pre-commit-config.yaml")
    let output_file = $repo_root | path join ".jj" "repo" "config.toml"

    if not ($config_file | path exists) {
        print -e $"Error: ($config_file) not found"
        exit 1
    }

    # Ensure output directory exists
    mkdir ($output_file | path dirname)

    # Parse YAML and generate config
    let hooks = open $config_file | get repos | get hooks | flatten

    let output = if $simple {
        generate_simple_config $hooks $config_file
    } else {
        let fix_configs = $hooks | each { |hook|
            generate_fix_config $hook.id $hook.entry ($hook.files? | default "")
        } | str join ""
        $"# Generated by jj-gen-fix-config from ($config_file)
# Regenerate with: jj-gen-fix-config

($fix_configs)"
    }

    $output | save -f $output_file

    print $"Generated ($output_file)"
    print $output
}

# Generate a "simple" config that uses pre-commit directly via a wrapper
def generate_simple_config [hooks, config_file: string] {
    # Collect all file patterns from hooks
    let all_patterns = $hooks | each { |hook|
        let files = $hook.files? | default ""
        if $files != "" {
            $files | split row ","
        } else {
            # Extract default patterns from known formatters
            match $hook.id {
                "nixfmt" | "nixfmt-rfc-style" | "alejandra" => ['glob:"**/*.nix"']
                "prettier" => ['glob:"**/*.json"', 'glob:"**/*.yaml"', 'glob:"**/*.yml"', 'glob:"**/*.md"']
                "rustfmt" => ['glob:"**/*.rs"']
                "shfmt" => ['glob:"**/*.sh"', 'glob:"**/*.bash"']
                "taplo-fmt" | "taplo" => ['glob:"**/*.toml"']
                "cargo-sort" => ['glob:"**/Cargo.toml"']
                "eslint" => ['glob:"**/*.js"', 'glob:"**/*.jsx"', 'glob:"**/*.ts"', 'glob:"**/*.tsx"', 'glob:"**/*.cjs"', 'glob:"**/*.mjs"']
                "markdownlint-fix" | "markdownlint-cli2-fix" => ['glob:"**/*.md"', 'glob:"**/*.markdown"']
                "cspell" => ['glob:"**/*.md"', 'glob:"**/*.txt"', 'glob:"**/README*"', 'glob:"**/*.rs"', 'glob:"**/*.js"', 'glob:"**/*.ts"', 'glob:"**/*.py"', 'glob:"**/*.go"']
                "black" | "isort" => ['glob:"**/*.py"', 'glob:"**/*.pyi"']
                "gofmt" => ['glob:"**/*.go"']
                _ => []
            }
        }
    } | flatten | uniq

    # Default to all files if no patterns found
    let patterns = if ($all_patterns | is-empty) {
        ['glob:"**/*"']
    } else {
        $all_patterns
    }

    # Format patterns array for TOML
    let patterns_toml = $patterns | each { |p| $"  '($p)'," } | str join "\n"

    # Generate the wrapper script path
    let wrapper = $"($env.HOME? | default "/tmp")/.local/bin/jj-pre-commit-wrapper"

    # Build output in parts to avoid complex escaping
    let header = "# Generated by jj-gen-fix-config --simple from " + $config_file + "\n# Regenerate with: jj-gen-fix-config --simple\n"
    let tool_config = "
[fix.tools.pre-commit]
command = [
  '" + $wrapper + "',
  " + "'$path'" + ",
]
patterns = [
" + $patterns_toml + "
]
"
    let note = "\n# NOTE: Ensure the wrapper script exists at " + $wrapper + "\n"
    let script = "# Create it with:
#   mkdir -p ~/.local/bin
#   cat > ~/.local/bin/jj-pre-commit-wrapper << 'EOF'
# #!/usr/bin/env bash
# # Wrapper to run pre-commit on stdin content via temp file
# set -euo pipefail
# path=\"$1\"
# tmpfile=$(mktemp)
# trap 'rm -f $tmpfile' EXIT
# cat > \"$tmpfile\"
# cp \"$tmpfile\" \"$path\"
# pre-commit run --files \"$path\" 2>/dev/null || true
# cat \"$path\"
# EOF
#   chmod +x ~/.local/bin/jj-pre-commit-wrapper"

    $header + $tool_config + $note + $script
}

def get_rust_edition [] {
    let repo_root = ^jj root
    let cargo_toml = $repo_root | path join "Cargo.toml"
    if ($cargo_toml | path exists) {
        let toml = open $cargo_toml
        ($toml.package?.edition? | default ($toml.workspace?.package?.edition? | default "2024"))
    } else {
        "2024"
    }
}

def generate_fix_config [id: string, entry: string, files: string] {
    # Extract base command (first space-separated word)
    # NOTE: use split row " " not split words to handle nix store paths correctly
    let cmd = $entry | lines | first | split row " " | first
    let cmd_name = $cmd | path basename | str replace -r "-[^-]+$" ""  # strip version suffix like -bin

    match $id {
        "nixfmt" | "nixfmt-rfc-style" => $"[fix.tools.nixfmt]
command = [
  '($cmd)',
]
patterns = [
  'glob:\"**/*.nix\"',
]
"
        "prettier" => $"[fix.tools.prettier]
command = [
  '($cmd)',
  '--stdin-filepath',
  '$path',
]
patterns = [
  'glob:\"**/*.json\"',
  'glob:\"**/*.yaml\"',
  'glob:\"**/*.yml\"',
  'glob:\"**/*.md\"',
]
"
        "rustfmt" => {
            let rust_edition = get_rust_edition
            $"[fix.tools.rustfmt]
# TODO: use `cargo fmt`
command = [
  'rustfmt',
  '--edition=($rust_edition)',
  '--emit=stdout',
]
patterns = [
  'glob:\"**/*.rs\"',
]
"
        }
        "shfmt" => $"[fix.tools.shfmt]
command = [
  '($cmd)',
]
patterns = [
  'glob:\"**/*.sh\"',
  'glob:\"**/*.bash\"',
]
"
        "taplo-fmt" | "taplo" => "[fix.tools.taplo]
command = [
  'taplo',
  'fmt',
  '-',
]
patterns = [
  'glob:\"**/*.toml\"',
]
"
        "cargo-sort" => "[fix.tools.cargo-sort]
command = [
  'cargo-sort',
  '--stdout',
  '-',
]
patterns = [
  'glob:\"**/Cargo.toml\"',
]
"
        "eslint" => $"[fix.tools.eslint]
command = [
  '($cmd)',
  '--stdin',
  '--stdin-filename',
  '$path',
  '--fix-dry-run',
  '--format=compact',
]
patterns = [
  'glob:\"**/*.js\"',
  'glob:\"**/*.jsx\"',
  'glob:\"**/*.ts\"',
  'glob:\"**/*.tsx\"',
  'glob:\"**/*.cjs\"',
  'glob:\"**/*.mjs\"',
]
"
        "markdownlint-fix" | "markdownlint-cli2-fix" => "[fix.tools.markdownlint]
command = [
  'markdownlint-cli2',
  '--fix',
  '--stdin',
]
patterns = [
  'glob:\"**/*.md\"',
  'glob:\"**/*.markdown\"',
]
"
        "cspell" => $"[fix.tools.cspell]
command = [
  '($cmd)',
  'lint',
  '--fix',
  '--stdin',
  '--file-type=auto',
  '$path',
]
patterns = [
  'glob:\"**/*.md\"',
  'glob:\"**/*.txt\"',
  'glob:\"**/README*\"',
  'glob:\"**/*.rs\"',
  'glob:\"**/*.js\"',
  'glob:\"**/*.ts\"',
  'glob:\"**/*.py\"',
  'glob:\"**/*.go\"',
]
"
        "black" => $"[fix.tools.black]
command = [
  '($cmd)',
  '--stdin-filename',
  '$path',
  '-',
]
patterns = [
  'glob:\"**/*.py\"',
  'glob:\"**/*.pyi\"',
]
"
        "isort" => $"[fix.tools.isort]
command = [
  '($cmd)',
  '--stdout',
  '--filename',
  '$path',
  '-',
]
patterns = [
  'glob:\"**/*.py\"',
]
"
        "gofmt" => $"[fix.tools.gofmt]
command = [
  '($cmd)',
]
patterns = [
  'glob:\"**/*.go\"',
]
"
        "alejandra" => $"[fix.tools.alejandra]
command = [
  '($cmd)',
  '--quiet',
  '--stdin',
]
patterns = [
  'glob:\"**/*.nix\"',
]
"
        _ => {
            # Try matching by command name for custom hook IDs
            match $cmd_name {
                "nixfmt" => $"[fix.tools.nixfmt]
command = [
  '($cmd)',
]
patterns = [
  'glob:\"**/*.nix\"',
]
"
                "prettier" => $"[fix.tools.prettier]
command = [
  '($cmd)',
  '--stdin-filepath',
  '$path',
]
patterns = [
  'glob:\"**/*.json\"',
  'glob:\"**/*.yaml\"',
  'glob:\"**/*.yml\"',
  'glob:\"**/*.md\"',
]
"
                "rustfmt" => {
                    let rust_edition = get_rust_edition
                    $"[fix.tools.rustfmt]
command = [
  'rustfmt',
  '--edition=($rust_edition)',
  '--emit=stdout',
]
patterns = [
  'glob:\"**/*.rs\"',
]
"
                }
                "shfmt" => $"[fix.tools.shfmt]
command = [
  '($cmd)',
]
patterns = [
  'glob:\"**/*.sh\"',
  'glob:\"**/*.bash\"',
]
"
                "taplo" => "[fix.tools.taplo]
command = [
  'taplo',
  'fmt',
  '-',
]
patterns = [
  'glob:\"**/*.toml\"',
]
"
                "markdownlint-cli2" => "[fix.tools.markdownlint]
command = [
  'markdownlint-cli2',
  '--fix',
  '--stdin',
]
patterns = [
  'glob:\"**/*.md\"',
  'glob:\"**/*.markdown\"',
]
"
                "cspell" => $"[fix.tools.cspell]
command = [
  '($cmd)',
  'lint',
  '--fix',
  '--stdin',
  '--file-type=auto',
  '$path',
]
patterns = [
  'glob:\"**/*.md\"',
  'glob:\"**/*.txt\"',
  'glob:\"**/README*\"',
  'glob:\"**/*.rs\"',
  'glob:\"**/*.js\"',
  'glob:\"**/*.ts\"',
  'glob:\"**/*.py\"',
  'glob:\"**/*.go\"',
]
"
                "black" => $"[fix.tools.black]
command = [
  '($cmd)',
  '--stdin-filename',
  '$path',
  '-',
]
patterns = [
  'glob:\"**/*.py\"',
  'glob:\"**/*.pyi\"',
]
"
                "isort" => $"[fix.tools.isort]
command = [
  '($cmd)',
  '--stdout',
  '--filename',
  '$path',
  '-',
]
patterns = [
  'glob:\"**/*.py\"',
]
"
                "gofmt" => $"[fix.tools.gofmt]
command = [
  '($cmd)',
]
patterns = [
  'glob:\"**/*.go\"',
]
"
                "alejandra" => $"[fix.tools.alejandra]
command = [
  '($cmd)',
  '--quiet',
  '--stdin',
]
patterns = [
  'glob:\"**/*.nix\"',
]
"
                _ => {
                    let lines = $entry | lines | length
                    if $lines > 1 {
                        print -e ("# Skipping " + $id + ": multi-line script (not a simple stdin→stdout formatter)")
                    } else if ($id | str contains "check-") {
                        print -e ("# Skipping " + $id + ": pre-commit checker (not an auto-formatter)")
                    } else if $id == "clippy" {
                        print -e ("# Skipping " + $id + ": linter (outputs diagnostics, not formatted code)")
                    } else if $id == "commitlint" {
                        print -e ("# Skipping " + $id + ": commit message validator (not a file formatter)")
                    } else {
                        print -e ("# Skipping " + $id + ": not a known stdin→stdout formatter (entry: " + $cmd + ")")
                    }
                    ""
                }
            }
        }
    }
}
